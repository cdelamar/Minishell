static void	echo_output(char **split_line, int i)
{
	int	start;

	start = i;
	while (split_line[start])
	{
		ft_putstr_fd(split_line[start], 1);
		start++;
		if (split_line[start])
			ft_putchar_fd(' ', 1);
	}
	return ;
}

int	ft_echo(char **split_line)
{
    int		i;
    int		j;
    bool	newline;

    i = 1;
    newline = true;

    while (split_line[i] && split_line[i][0] == '-')
    {
        j = 1;
        while (split_line[i][j] == 'n')
            j++;
        if (split_line[i][j] != '\0')
            break;
        newline = false;
        i++;
    }
    echo_output(split_line, i);
    if (newline)
        ft_putchar_fd('\n', 1);
    return (EXIT_SUCCESS);
}

int	ft_builtin(char *line, t_cmd *cmd)
{
    char	**split_line;
    int     saved_stdin, saved_stdout;

    split_line = ft_split(line, ' ');
    if (backup_fd(&saved_stdin, &saved_stdout) < 0) {
        ft_freetab(split_line);
        return (EXIT_FAILURE);
    }

    if (handle_redirections(split_line) == EXIT_FAILURE) {
        restore_fd(saved_stdin, saved_stdout);
        ft_freetab(split_line);
        return (EXIT_FAILURE);
    }

    if (ft_strcmp(split_line[0], "unset") == 0)
        return (ft_unset(split_line, cmd));
    else if (ft_strcmp(split_line[0], "echo") == 0) {
        int ret = ft_echo(split_line);
        restore_fd(saved_stdin, saved_stdout);
        ft_freetab(split_line);
        return ret;
    }
    else if (ft_strcmp(split_line[0], "cd") == 0) {
        int ret = ft_cd(split_line[1]);
        restore_fd(saved_stdin, saved_stdout);
        ft_freetab(split_line);
        return ret;
    }
    else if (ft_strcmp(split_line[0], "export") == 0) {
        int ret = ft_export(split_line, cmd);
        restore_fd(saved_stdin, saved_stdout);
        ft_freetab(split_line);
        return ret;
    }
    else if (ft_strcmp(line, "env") == 0) {
        ft_freetab(split_line);
        int ret = ft_env(cmd);
        restore_fd(saved_stdin, saved_stdout);
        return ret;
    }
    else if (ft_strcmp(line, "pwd") == 0) {
        ft_freetab(split_line);
        int ret = ft_pwd();
        restore_fd(saved_stdin, saved_stdout);
        return ret;
    }

    restore_fd(saved_stdin, saved_stdout);
    ft_freetab(split_line);
    return (EXIT_FAILURE);
}

char	*cmd_cat(const char *path_split, char *slash, char *command)
{
	size_t	s1_len;
	size_t	s2_len;
	size_t	s3_len;
	char	*res;

	s1_len = ft_strlen(path_split);
	s2_len = ft_strlen(slash);
	s3_len = ft_strlen(command);
	res = malloc((s1_len + s2_len + s3_len + 1) * sizeof(char));
	if (!res)
		return (NULL);
	ft_strlcpy(res, path_split, s1_len + 1);
	ft_strlcat(res, slash, s1_len + s2_len + 1);
	ft_strlcat(res, command, ft_strlen(res) + s3_len + 1);
	return (res);
}

char	*cmd_finder(char **split_line, t_cmd *cmd)
{
	int		i;
	char	*command;

	i = 0;
	while (cmd->path_split[i])
	{
		command = cmd_cat(cmd->path_split[i], "/", split_line[0]);
		if (access (command, 0) == 0)
			return (command);
		free(command);
		i++;
	}
	return (NULL);
}

void sigint_handler(int sig)
{
    if (sig == SIGINT)
	{
        rl_replace_line("", 0);
        printf("\n");
        rl_on_new_line();
        rl_redisplay();
    }
}

void	signals(void)
{
	signal(SIGINT, sigint_handler);
	signal(SIGQUIT, SIG_IGN); // CTRL + \ interaction
}

int ft_heredoc(char *limit)
{
    char    *line;
    int     fd;

	line = NULL;
	fd = open("/tmp/heredoc_tmp", O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd < 0)
    {
        printf("ERROR heredoc.c : line 13\n");
        return(EXIT_FAILURE);
    }

    while (1)
    {
        printf("heredoc> ");
        line = get_next_line(STDIN_FILENO);
        if (!line)
            break;

        // r0emove 'trailing' newline charac
        line[ft_strcspn(line, "\n")] = 0;

        // on regarde si c'est pas le delimiteur
        if (ft_strcmp(line, limit) == 0)
        {
            free(line);
            break;
        }

		// WORK IN PROGRESS, test pour eviter de planter en cas de mauvais commande
		if (write(fd, line, strlen(line)) == -1 || write(fd, "\n", 1) == -1)
        {
            printf("ERROR (heredoc.c line 37)\n");
            free(line);
            close(fd);
            return (EXIT_FAILURE);
        }

        // et la bam affichage
        //printf("%s\n", line);
        free(line);
    }

    close(fd);

    // la va falloir revoir le truc parce que ca pars dans tous les sens
    fd = open("/tmp/heredoc_tmp", O_RDONLY);
    if (fd < 0)
    {
        printf("ERROR heredoc.c : line 45\n");
        return(EXIT_FAILURE);
    }
    dup2(fd, STDIN_FILENO);
    close(fd);

    // Optionnel ???
    unlink("/tmp/heredoc_tmp");

    return (EXIT_SUCCESS);
}

int backup_fd(int *saved_stdin, int *saved_stdout) {
    *saved_stdin = dup(STDIN);
    if (*saved_stdin < 0)
        return -1;
    *saved_stdout = dup(STDOUT);
    if (*saved_stdout < 0) {
        close(*saved_stdin);
        return -1;
    }
    return 0;
}

void restore_fd(int saved_stdin, int saved_stdout) {
    dup2(saved_stdin, STDIN);
    close(saved_stdin);
    dup2(saved_stdout, STDOUT);
    close(saved_stdout);
}

int handle_redirections(char **args)
{
    int i;
    int fd;

    i = 0;
    while (args[i])
    {
        if (ft_strcmp(args[i], ">") == 0)
        {
            fd = open(args[i + 1], O_WRONLY | O_CREAT | O_TRUNC, 0644);
            if (fd < 0)
            {
                printf ("ERROR (redirection.c line 16)\n");
                return (EXIT_FAILURE);
            }
            dup2(fd, STDOUT_FILENO);
            close(fd);
            args[i] = NULL;
        }
        else if (ft_strcmp(args[i], ">>") == 0)
        {
            fd = open(args[i + 1], O_WRONLY | O_CREAT | O_APPEND, 0644);
            if (fd < 0)
            {
                printf ("ERROR (redirection.c line 28)\n");
                return (EXIT_FAILURE);
            }
            dup2(fd, STDOUT_FILENO);
            close(fd);
            args[i] = NULL;
        }
        else if (ft_strcmp(args[i], "<") == 0)
        {
            fd = open(args[i + 1], O_RDONLY);
            if (fd < 0)
            {
                printf ("ERROR (redirection.c line 40)\n");
                return (EXIT_FAILURE);
            }
            dup2(fd, STDIN_FILENO);
            close(fd);
            args[i] = NULL;
        }
        else if (ft_strcmp(args[i], "<<") == 0)
        {
            if (ft_heredoc(args[i + 1]) != 0)
            {
                printf ("ERROR (redirection.c line 48)\n");
                return (EXIT_FAILURE);
            }
            args[i] = NULL;
        }
        i++;
    }
    return (EXIT_SUCCESS);
}

int	execute(char *line, t_cmd *cmd)
{
	if (line[0] == '\0')
	{
		printf("free (exec.c : line 7)\n");
		return (0);
	}
	if (ft_strchr(line, '|'))
		return (pipe_execute(line, cmd));
	else if (ft_builtin(line, cmd) == EXIT_SUCCESS)
		return (0);
	return (basic_execute(line, cmd));
}

	// else if (le builtin marche pas) ->error_message

int pipe_execute(char *line, t_cmd *cmd)
{
	int i;
	int fd[2];
	int status;
	pid_t pid;

int	execute(char *line, t_cmd *cmd)
{
	if (line[0] == '\0')
	{
		printf("free (exec.c : line 7)\n");
		return (0);
	}
	if (ft_strchr(line, '|'))
		return (pipe_execute(line, cmd));
	else if (ft_builtin(line, cmd) == EXIT_SUCCESS)
		return (0);
	return (basic_execute(line, cmd));
}

	// else if (le builtin marche pas) ->error_message

int pipe_execute(char *line, t_cmd *cmd)
{
	int i;
	int fd[2];
	int status;
	pid_t pid;

	i = 0;
	cmd->fd_in = 0; // Initialize the input for the first command

	cmd->path_command = ft_split(line, '|');

	while (cmd->path_command[i])
	{
		if (pipe(fd) < 0)
		{
			printf("ERROR (exec.c line 30)\n");
			ft_freetab(cmd->path_command);
			return (EXIT_FAILURE);
		}

		pid = fork();
		if (pid < 0)
		{
			printf("ERROR (exec.c line 37)\n");
			close(fd[0]);
			close(fd[1]);
			ft_freetab(cmd->path_command);
			return (EXIT_FAILURE);
		}
		else if (pid == 0)
		{
			dup2(cmd->fd_in, 0); // Get input from the previous command
			if (cmd->path_command[i + 1])
				dup2(fd[1], 1); // Output to the next command

			close(fd[0]);
			close(fd[1]);
			close(cmd->fd_in);

			if (basic_execute(cmd->path_command[i], cmd) == EXIT_FAILURE)
			{
				ft_freetab(cmd->path_command);
				exit(EXIT_FAILURE);
			}
			exit(EXIT_SUCCESS);
		}
		else
		{
			waitpid(pid, &status, 0);
			close(fd[1]);
			if (cmd->fd_in)
				close(cmd->fd_in);
			cmd->fd_in = fd[0]; // Save the input for the next command
			i++;
		}
	}

	close(cmd->fd_in);
	if (cmd->path_command)
		ft_freetab(cmd->path_command);
	return (EXIT_SUCCESS);
}

int basic_execute (char *line, t_cmd *cmd)
{
	char	*command;
	char	**split_line;
	int		status;
	// int		i;

	// i = 0;
	split_line = NULL;
	// exit_handler
	if (strcmp(line, "exit") == 0)
		return(EXIT_COMMAND);
	ft_path(cmd);
	if (!cmd->path)
	{
		printf("command not found\n");
		return (EXIT_SUCCESS);
	}
	cmd->pid1 = fork();

	//  error fork
	if (cmd->pid1 < 0)
		return (1);

	// child fork
	else if (cmd->pid1 == 0)
	{
		split_line = ft_split(line, ' ');

		if (handle_redirections(split_line) < 0)
		{
			printf("ERROR (exec.c line 117)\n");
			return (EXIT_FAILURE);
		}
		command = cmd_finder(split_line, cmd);
		if(command)
			execve(command, split_line, cmd->env);
		printf ("incorrect inputs : exec.c (line 123)\n");
		ft_freetab(split_line);
		//return (EXIT_FAILURE); // error

		if(waitpid(cmd->pid1, &status, 0) == -1)
		{
			printf("freetab (exec.c TEST line 129)\n");
			ft_freetab(split_line);
			return (EXIT_FAILURE);
		}
		if (WIFEXITED(status) && WEXITSTATUS(status) == EXIT_FAILURE)
		{
			printf("freetab (exec.c TEST line 135)\n");
			ft_freetab(split_line);
			return (EXIT_FAILURE);
		}
		printf("parent fork() (exec.c TEST line 139)\n");
	}

	else
	{
		if(waitpid(cmd->pid1, &status, 0) == -1)
		{
			printf("freetab (exec.c line 146)\n");
			ft_freetab(split_line);
			return (EXIT_FAILURE);
		}
		if (WIFEXITED(status) && WEXITSTATUS(status) == EXIT_FAILURE)
		{
			printf("freetab (exec.c line 152)\n");
			ft_freetab(split_line);
			return (EXIT_FAILURE);
		}
		//printf("parent fork() (exec.c line 156)\n");
		//ft_freetab(split_line);
	}
	return (EXIT_SUCCESS);
}

	i = 0;
	cmd->fd_in = 0; // Initialize the input for the first command

	cmd->path_command = ft_split(line, '|');

	while (cmd->path_command[i])
	{
		if (pipe(fd) < 0)
		{
			printf("ERROR (exec.c line 30)\n");
			ft_freetab(cmd->path_command);
			return (EXIT_FAILURE);
		}

		pid = fork();
		if (pid < 0)
		{
			printf("ERROR (exec.c line 37)\n");
			close(fd[0]);
			close(fd[1]);
			ft_freetab(cmd->path_command);
			return (EXIT_FAILURE);
		}
		else if (pid == 0)
		{
			dup2(cmd->fd_in, 0); // Get input from the previous command
			if (cmd->path_command[i + 1])
				dup2(fd[1], 1); // Output to the next command

			close(fd[0]);
			close(fd[1]);
			close(cmd->fd_in);

			if (basic_execute(cmd->path_command[i], cmd) == EXIT_FAILURE)
			{
				ft_freetab(cmd->path_command);
				exit(EXIT_FAILURE);
			}
			exit(EXIT_SUCCESS);
		}
		else
		{
			waitpid(pid, &status, 0);
			close(fd[1]);
			if (cmd->fd_in)
				close(cmd->fd_in);
			cmd->fd_in = fd[0]; // Save the input for the next command
			i++;
		}
	}

	close(cmd->fd_in);
	if (cmd->path_command)
		ft_freetab(cmd->path_command);
	return (EXIT_SUCCESS);
}

int basic_execute (char *line, t_cmd *cmd)
{
	char	*command;
	char	**split_line;
	int		status;
	// int		i;

	// i = 0;
	split_line = NULL;
	// exit_handler
	if (strcmp(line, "exit") == 0)
		return(EXIT_COMMAND);
	ft_path(cmd);
	if (!cmd->path)
	{
		printf("command not found\n");
		return (EXIT_SUCCESS);
	}
	cmd->pid1 = fork();

	//  error fork
	if (cmd->pid1 < 0)
		return (1);

	// child fork
	else if (cmd->pid1 == 0)
	{
		split_line = ft_split(line, ' ');

		if (handle_redirections(split_line) < 0)
		{
			printf("ERROR (exec.c line 117)\n");
			return (EXIT_FAILURE);
		}
		command = cmd_finder(split_line, cmd);
		if(command)
			execve(command, split_line, cmd->env);
		printf ("incorrect inputs : exec.c (line 123)\n");
		ft_freetab(split_line);
		//return (EXIT_FAILURE); // error

		if(waitpid(cmd->pid1, &status, 0) == -1)
		{
			printf("freetab (exec.c TEST line 129)\n");
			ft_freetab(split_line);
			return (EXIT_FAILURE);
		}
		if (WIFEXITED(status) && WEXITSTATUS(status) == EXIT_FAILURE)
		{
			printf("freetab (exec.c TEST line 135)\n");
			ft_freetab(split_line);
			return (EXIT_FAILURE);
		}
		printf("parent fork() (exec.c TEST line 139)\n");
	}

	else
	{
		if(waitpid(cmd->pid1, &status, 0) == -1)
		{
			printf("freetab (exec.c line 146)\n");
			ft_freetab(split_line);
			return (EXIT_FAILURE);
		}
		if (WIFEXITED(status) && WEXITSTATUS(status) == EXIT_FAILURE)
		{
			printf("freetab (exec.c line 152)\n");
			ft_freetab(split_line);
			return (EXIT_FAILURE);
		}
		//printf("parent fork() (exec.c line 156)\n");
		//ft_freetab(split_line);
	}
	return (EXIT_SUCCESS);
}


int main(int argc, char **argv, char **envp)
{
	char *line;
	t_cmd *cmd;
	t_ctx *ctx;
	t_token *token;

	(void)argc;
	(void)argv;

	// CTRL + C and CTRL + '\'
	signals();

	// SHELL LOOP
	while (1)
	{
		if (malloc_structs(&cmd, &ctx, &token) != 0)
		{
			ft_putendl_fd(MALLOC_FAILURE, 2);
			return (1);
		}
		cmd->env = envp;
		/*if (ft_copy_envp(envp, cmd) == 1)
			return (EXIT_FAILURE);*/
		line = readline("MINISHELL>");

		// CTRL + D
		if (line == NULL)
		{
			free_structs(cmd, ctx, token);
			printf("CTRL + D\n");
			return (0);
		}

		// HISTORY LINE
		if (*line)
			add_history(line);

		// EXECUTING
		if (execute(line, cmd) == EXIT_COMMAND) // define OK ?
		{
			// modif de var_g
			free_structs(cmd, ctx, token);
			free(line);
			return (0);
		}
		free_structs(cmd, ctx, token);
		free(line);
	}
	// free_structs(cmd, ctx, token);
	// free(line);
	return (0);
}